package org.nalby.yobatis.mybatis;

import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.mybatis.generator.api.GeneratedJavaFile;
import org.mybatis.generator.api.GeneratedXmlFile;
import org.mybatis.generator.api.LibraryRunner;
import org.mybatis.generator.exception.InvalidConfigurationException;
import org.nalby.yobatis.exception.InvalidMybatisGeneratorConfigException;
import org.nalby.yobatis.exception.ProjectException;
import org.nalby.yobatis.structure.Project;
import org.nalby.yobatis.util.Expect;
import org.nalby.yobatis.util.FolderUtil;

/**
 * Used to write files generated by mybatis-generator
 * to corresponding directories.
 * @author Kyle Lin
 */
public class MybatisFilesWriter {

	private LibraryRunner runner;

	private MybatisConfigReader reader;

	private Project project;

	public MybatisFilesWriter(Project project, MybatisConfigReader configReader) {
		Expect.notNull(project, "project must not be null.");
		Expect.notNull(configReader, "configReader must not be null.");
		this.project = project;
		this.runner = new LibraryRunner();
		try {
			this.runner.parse(project.openFile(configReader.getConfigeFilename()));
		} catch (InvalidConfigurationException e) {
			throw new InvalidMybatisGeneratorConfigException(e);
		}
		if (runner.getGeneratedJavaFiles() == null) {
			throw new ProjectException("No java files generated.");
		}
		if (runner.getGeneratedXmlFiles() == null) {
			throw new ProjectException("No xml files generated.");
		}
		this.reader = configReader;
	}

	private List<GeneratedJavaFile> listFile(String suffix) {
		List<GeneratedJavaFile> result = new LinkedList<GeneratedJavaFile>();
		List<GeneratedJavaFile> javaFiles = runner.getGeneratedJavaFiles();
		for (GeneratedJavaFile file : javaFiles) {
			if (file.getFileName() != null
					&& file.getFileName().endsWith(suffix)) {
				result.add(file);
			}
		}
		return result;
	}

	private List<GeneratedJavaFile> getMapperFiles() {
		return listFile("Mapper.java");
	}
	
	private List<GeneratedJavaFile> getCriteriaFiles() {
		return listFile("Criteria.java");
	}

	public List<GeneratedJavaFile> getDomainFiles() {
		List<GeneratedJavaFile> javaFiles = runner.getGeneratedJavaFiles();
		List<GeneratedJavaFile> result = new LinkedList<GeneratedJavaFile>();
		for (GeneratedJavaFile file : javaFiles) {
			if (file.getFileName() != null &&
				(!file.getFileName().endsWith("Mapper.java") &&
				 !file.getFileName().endsWith("Criteria.java"))) {
				result.add(file);
			}
		}
		return result;
	}
	
	private final static Pattern PACKAGE_PATTERN = Pattern.compile("^package\\s+(.+);");
	private String modifyPackagePathOfCriteria(String content) {
		Matcher matcher = PACKAGE_PATTERN.matcher(content);
		if (!matcher.find()) {
			throw new IllegalArgumentException("Failed to replace package clause.");
		}
		String name = matcher.group(1);
		return content.replaceFirst(name, name + ".criteria");
	}
	
	/* The renameClassName plug-in does not rename methods. */
	private String replaceExamples(String newContent) {
		newContent = newContent.replaceFirst("countByExample", "countByCriteria");
		newContent = newContent.replaceFirst("deleteByExample", "deleteByCriteria");
		newContent = newContent.replaceFirst("selectByExample", "selectByCriteria");
		newContent = newContent.replaceFirst("updateByExampleSelective", "updateByCriteriaSelective");
		return newContent.replaceFirst("updateByExample", "updateByCriteria");
	}
	
	/*
	 * import xxx.domain.XXXCriteria; -> import xxx.domain.criteria.XXXCriteria;
	 */
	private String correctMapper(String content, String domainPackageName) {
		String patternStr = "import\\s+" + domainPackageName + "\\.(.+Criteria);";
		Pattern pattern = Pattern.compile(patternStr);
		Matcher matcher = pattern.matcher(content);
		if (!matcher.find()) {
			throw new IllegalArgumentException("Failed to replace clause of import criteria.");
		}
		String name = matcher.group(1);
		String newContent = content.replaceFirst(patternStr , "import " + domainPackageName + ".criteria." + name + ";");
		return replaceExamples(newContent);
	}

	private String correctXmlContent(String content, String domainPackageName) {
		String patternStr = domainPackageName + "\\.(.+Criteria)";
		Pattern pattern = Pattern.compile(patternStr);
		Matcher matcher = pattern.matcher(content);
		if (!matcher.find()) {
			throw new IllegalArgumentException("Failed to replace parameterType of criteria.");
		}
		String name = matcher.group(1);
		String newContent = content.replaceAll(patternStr , domainPackageName + ".criteria." + name);
		return replaceExamples(newContent);
	}
	
	
	private List<GeneratedXmlFile> getXmlFiles() {
		return runner.getGeneratedXmlFiles();
	}
	
	private void writeJavaMappers() {
		List<GeneratedJavaFile> files = getMapperFiles();
		for (GeneratedJavaFile file : files) {
			String path = FolderUtil.concatPath(reader.getDaoDirPath(), file.getFileName());
			String content = file.getFormattedContent();
			String domainPackage = reader.getPackageNameOfDomains();
			project.writeFile(path, correctMapper(content, domainPackage));
		}
	}
	
	private void writeJavaDomains() {
		List<GeneratedJavaFile> files = getDomainFiles();
		for (GeneratedJavaFile file : files) {
			String path = reader.getDomainDirPath() + "/" + file.getFileName();
			project.writeFile(path, file.getFormattedContent());
		}
	}
	
	private void writeCriteriaFiles() {
		List<GeneratedJavaFile> files = getCriteriaFiles();
		for (GeneratedJavaFile file : files) {
			String path = FolderUtil.concatPath(reader.getCriteriaDirPath(), file.getFileName());
			project.writeFile(path, modifyPackagePathOfCriteria(file.getFormattedContent()));
		}
	}
	

	
	private void writeXmlFiles() {
		List<GeneratedXmlFile> xmlFiles = getXmlFiles();
		for (GeneratedXmlFile file : xmlFiles) {
			String domainPackage = reader.getPackageNameOfDomains();
			String path = FolderUtil.concatPath(reader.getMapperDirPath(), file.getFileName());
			String content = correctXmlContent(file.getFormattedContent(), domainPackage);
			project.writeFile(path, content);
		}
	}

	public void writeAll() {
		writeCriteriaFiles();
		writeJavaDomains();
		writeJavaMappers();
		writeXmlFiles();
	}

}
