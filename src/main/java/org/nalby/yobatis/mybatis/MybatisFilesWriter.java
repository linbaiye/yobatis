package org.nalby.yobatis.mybatis;

import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.mybatis.generator.api.GeneratedFile;
import org.mybatis.generator.api.GeneratedJavaFile;
import org.mybatis.generator.api.GeneratedXmlFile;
import org.mybatis.generator.api.LibraryRunner;
import org.nalby.yobatis.exception.InvalidMybatisGeneratorConfigException;
import org.nalby.yobatis.log.LogFactory;
import org.nalby.yobatis.log.Logger;
import org.nalby.yobatis.structure.File;
import org.nalby.yobatis.structure.Project;
import org.nalby.yobatis.util.Expect;
import org.nalby.yobatis.util.FolderUtil;
import org.nalby.yobatis.xml.SqlMapperParser;

/**
 * Write files generated by MyBatis Generator to corresponding directories.
 * @author Kyle Lin
 */
public class MybatisFilesWriter {

	private LibraryRunner runner;

	private Project project;
	
	private Logger logger = LogFactory.getLogger(MybatisFilesWriter.class);
	
	@FunctionalInterface
	private interface FileSelector {
		boolean select(GeneratedFile file);
	}

	public MybatisFilesWriter(Project project, LibraryRunner mybatisRunner) {
		Expect.notNull(project, "project must not be null.");
		Expect.notNull(mybatisRunner, "mybatisRunner must not be null.");
		this.project = project;
		this.runner = mybatisRunner;
		if (runner.getGeneratedJavaFiles() == null) {
			throw new InvalidMybatisGeneratorConfigException("No java files generated.");
		}
		if (runner.getGeneratedXmlFiles() == null) {
			throw new InvalidMybatisGeneratorConfigException("No xml files generated.");
		}
	}
	

	private List<GeneratedJavaFile> selectFiles(FileSelector selector) {
		List<GeneratedJavaFile> result = new LinkedList<GeneratedJavaFile>();
		List<GeneratedJavaFile> javaFiles = runner.getGeneratedJavaFiles();
		for (GeneratedJavaFile file : javaFiles) {
			if (selector.select(file)) {
				result.add(file);
			}
		}
		return result;
	}

	private List<GeneratedJavaFile> listFile(final String suffix) {
		return selectFiles((GeneratedFile file) -> {
			return file.getFileName() != null &&
					file.getFileName().endsWith(suffix);
		});
	}

	private List<GeneratedJavaFile> getDomainFiles() {
		return selectFiles((GeneratedFile file) -> {
			return file.getFileName() != null &&
					!file.getFileName().endsWith("Mapper.java") &&
					!file.getFileName().endsWith("Criteria.java");
		});
	}
	
	
	private void writeFile(String path, String content, boolean overwrite) {
		File file = project.findFile(path);
		if (file == null || overwrite) {
			file = project.createFile(path);
			file.write(content);
		}
	}
	
	private void writeJavaMappers() {
		for (GeneratedJavaFile javafile : listFile("Mapper.java")) {
			writeJavaFile(javafile, false);
		}
	}
	
	
	private static final Pattern BASE_CLASS_PATTERN = Pattern.compile("public abstract class [^\\s]+ \\{");
	
	private boolean isBaseModelClass(GeneratedJavaFile javaFile) {
		Matcher matcher = BASE_CLASS_PATTERN.matcher(javaFile.getFormattedContent());
		return matcher.find();
	}
	

	private void writeJavaFile(GeneratedJavaFile javafile, boolean overwrite) {
		String dirpath = FolderUtil.concatPath(javafile.getTargetProject(), 
				javafile.getTargetPackage().replaceAll("\\.", "/"));
		String filepath = FolderUtil.concatPath(dirpath, javafile.getFileName());
		writeFile(filepath, javafile.getFormattedContent(), overwrite);
	}
	
	private void writeJavaDomains() {
		List<GeneratedJavaFile> files = getDomainFiles();
		for (GeneratedJavaFile javafile : files) {
			boolean overwrite = isBaseModelClass(javafile);
			writeJavaFile(javafile, overwrite);
		}
	}
	
	private void writeCriteriaFiles() {
		for (GeneratedJavaFile javafile : listFile("Criteria.java")) {
			writeJavaFile(javafile, true);
		}
	}
	
	private String mergeManualSqlXml(String path, String content) {
		File file = project.findFile(path);
		if (file != null) {
			try (InputStream inputStream = file.open()) {
				SqlMapperParser oldXml = new SqlMapperParser(inputStream);
				SqlMapperParser newXml = SqlMapperParser.fromString(content);
				newXml.merge(oldXml);
				return newXml.toXmlString();
			} catch (Exception e) {
				//Do nothing.
			}
		}
		return content;
	}
	
	private void writeXmlFiles() {
		List<GeneratedXmlFile> xmlFiles = runner.getGeneratedXmlFiles();
		for (GeneratedXmlFile xmlfile : xmlFiles) {
			String dirpath = FolderUtil.concatPath(xmlfile.getTargetProject(), 
					xmlfile.getTargetPackage().replaceAll("\\.", "/"));
			String filepath = FolderUtil.concatPath(dirpath, xmlfile.getFileName());
			String content = mergeManualSqlXml(filepath, xmlfile.getFormattedContent());
			writeFile(filepath, content, true);
		}
	}

	public void writeAll() {
		writeCriteriaFiles();
		writeJavaDomains();
		writeJavaMappers();
		writeXmlFiles();
		logger.info("Files have been generated, happy coding.");
	}

}
